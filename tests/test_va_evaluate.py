"""Test the va_evaluate function.

This is used to generate the basis functions and their derivatives
given the boundary points, the hessenbergs and the poles.
"""
from test_settings import ATOL, RTOL


def test_import_va_evaluate():
    """Test that the va_evaluate function can be imported."""
    from pylars.numerics import va_evaluate

    assert va_evaluate is not None


def test_small_va_evaluate():
    """Test the va_evaluate function for a small example."""
    from pylars.numerics import va_orthogonalise, va_evaluate
    import numpy as np

    Z = np.array([0, 2, 1 + 1j]).reshape(3, 1)
    n = 1
    hessenbergs, Q = va_orthogonalise(Z, n)
    H = hessenbergs[0]
    basis, basis_deriv = va_evaluate(Z, hessenbergs)
    basis_deriv_answer = np.array(
        [[0, 0, 0], [1 / H[1, 0], 1 / H[1, 0], 1 / H[1, 0]]]
    ).T
    assert np.allclose(basis, Q, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


def test_large_va_evaluate():
    """Test va_evaluate for a large example generated by the MATLAB code."""
    from pylars.numerics import va_orthogonalise, va_evaluate
    import numpy as np
    from scipy.io import loadmat

    Z = np.exp(1j * np.linspace(0, 2 * np.pi, 100)).reshape(100, 1)
    hessenbergs, Q = va_orthogonalise(Z, 10)
    basis, basis_deriv = va_evaluate(Z, hessenbergs)
    basis_answer = loadmat("tests/data/VAorthog_circle_R0.mat")["R0"]
    basis_deriv_answer = loadmat("tests/data/VAorthog_circle_R1.mat")["R1"]
    assert np.allclose(basis, basis_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


def test_small_poles_va_evaluate_1():
    from pylars.numerics import va_orthogonalise, va_evaluate
    import numpy as np

    Z = np.array([-4, 4]).reshape(2, 1)
    poles = [np.array([0])]
    hessenbergs, Q = va_orthogonalise(Z, 1, poles)
    basis, basis_deriv = va_evaluate(Z, hessenbergs, poles)
    basis_answer = np.array([[1, -1, -1], [1, 1, 1]])
    basis_deriv_answer = np.array([[0, 1 / 4, -1 / 4], [0, 1 / 4, -1 / 4]])
    assert np.allclose(basis, basis_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


def test_small_poles_va_evaluate_2():
    from pylars.numerics import va_orthogonalise, va_evaluate
    import numpy as np
    from scipy.io import loadmat

    Z = loadmat("tests/data/small_poles.mat")["Z"].reshape(3, 1)
    poles = loadmat("tests/data/small_poles.mat")["Pol"]
    poles = [
        poles[i, 0].reshape(
            -1,
        )
        for i in range(poles.shape[0])
    ]
    basis_answer = loadmat("tests/data/small_poles.mat")["R0"]
    basis_deriv_answer = loadmat("tests/data/small_poles.mat")["R1"]
    hessenbergs, Q = va_orthogonalise(Z, 0, poles)
    basis, basis_deriv = va_evaluate(Z, hessenbergs, poles)
    assert np.allclose(basis, basis_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


def test_large_poles_va_evaluate():
    """Test the va_orthogonalise with poles against the MATLAB code."""
    from pylars.numerics import va_orthogonalise, va_evaluate
    from pylars import Problem
    import numpy as np
    from scipy.io import loadmat

    n = 24
    num_poles = 24
    test_answers = loadmat(
        f"tests/data/lid_driven_cavity_n_{n}_np_{num_poles}.mat"
    )
    Z_answer = test_answers["Z"]
    poles_answer = test_answers["Pol"]
    basis_answer = test_answers["R0"]
    basis_deriv_answer = test_answers["R1"]
    poles_answer = np.array([poles_answer[0, i] for i in range(4)]).reshape(
        4, num_poles
    )
    corners = [1 + 1j, -1 + 1j, -1 - 1j, 1 - 1j]
    prob = Problem()
    prob.add_exterior_polygon(
        corners,
        num_edge_points=300,
        length_scale=1.5 * np.sqrt(2),
        deg_poly=24,
        num_poles=num_poles,
    )
    # check the MATALB prob.domainain points and poles are the same
    # check the polynomial coefficients are the same
    assert np.allclose(
        prob.domain.boundary_points, Z_answer, atol=ATOL, rtol=RTOL
    )
    assert np.allclose(prob.domain.poles, poles_answer, atol=ATOL, rtol=RTOL)

    hessenbergs, Q = va_orthogonalise(
        prob.domain.boundary_points.reshape(1200, 1),
        n,
        poles=prob.domain.poles,
    )
    basis, basis_deriv = va_evaluate(
        prob.domain.boundary_points, hessenbergs, poles=prob.domain.poles
    )
    # check the polynomial basis is the same
    assert np.allclose(
        basis[:, :25], basis_answer[:, :25], atol=ATOL, rtol=RTOL
    )
    assert np.allclose(
        basis_deriv[:, :25],
        basis_deriv_answer[:, :25],
        atol=ATOL,
        rtol=RTOL,
    )
    # check all the basis functions are the same
    assert np.allclose(basis, basis_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


def test_large_poles_va_evaluate_hypothesis():
    """Test the va_orthogonalise with poles against the MATLAB code."""
    from pylars.numerics import va_orthogonalise, va_evaluate
    from pylars import Problem
    import numpy as np
    from scipy.io import loadmat

    n = 0
    num_poles = 10
    test_answers = loadmat(
        f"tests/data/lid_driven_cavity_n_{n}_np_{num_poles}.mat"
    )
    Z_answer = test_answers["Z"]
    poles_answer = test_answers["Pol"]
    basis_answer = test_answers["R0"]
    basis_deriv_answer = test_answers["R1"]
    poles_answer = np.array([poles_answer[0, i] for i in range(4)]).reshape(
        4, num_poles
    )
    corners = [1 + 1j, -1 + 1j, -1 - 1j, 1 - 1j]
    prob = Problem()
    prob.add_exterior_polygon(
        corners,
        num_edge_points=300,
        length_scale=1.5 * np.sqrt(2),
        deg_poly=24,
        num_poles=num_poles,
    )
    # check the MATALB domain points and poles are the same
    # check the polynomial coefficients are the same
    assert np.allclose(
        prob.domain.boundary_points, Z_answer, atol=ATOL, rtol=RTOL
    )
    assert np.allclose(prob.domain.poles, poles_answer, atol=ATOL, rtol=RTOL)

    hessenbergs, Q = va_orthogonalise(
        prob.domain.boundary_points.reshape(1200, 1),
        0,
        poles=prob.domain.poles,
    )
    basis, basis_deriv = va_evaluate(
        prob.domain.boundary_points, hessenbergs, poles=prob.domain.poles
    )
    # check the polynomial basis is the same
    assert np.allclose(
        basis[:, :25], basis_answer[:, :25], atol=ATOL, rtol=RTOL
    )
    assert np.allclose(
        basis_deriv[:, :25], basis_deriv_answer[:, :25], atol=ATOL, rtol=RTOL
    )
    # check all the basis functions are the same
    assert np.allclose(basis, basis_answer, atol=ATOL, rtol=RTOL)
    assert np.allclose(basis_deriv, basis_deriv_answer, atol=ATOL, rtol=RTOL)


if __name__ == "__main__":
    test_import_va_evaluate()
    test_small_va_evaluate()
    test_large_va_evaluate()
    test_small_poles_va_evaluate_1()
    test_small_poles_va_evaluate_2()
    test_large_poles_va_evaluate()
